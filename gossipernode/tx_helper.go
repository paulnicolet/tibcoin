package gossipernode

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"math/big"
	"strconv"
)

func (tx *Tx) hash() [32]byte {
	h := sha256.New()

	// Hash inputs
	for _, input := range tx.Inputs {
		inputHash := input.hash()
		h.Write(inputHash[:])
	}

	// Hash outputs
	for _, output := range tx.Outputs {
		outputHash := output.hash()
		h.Write(outputHash[:])
	}

	// Hash signature
	h.Write(tx.Sig.R.Bytes())
	h.Write(tx.Sig.S.Bytes())

	// Hash Public Key
	h.Write(tx.PublicKey.X.Bytes())
	h.Write(tx.PublicKey.Y.Bytes())

	return BytesToHash(h.Sum(nil))
}

func (tx *Tx) getSignable() [32]byte {
	h := sha256.New()

	// Hash inputs
	for _, input := range tx.Inputs {
		inputHash := input.hash()
		h.Write(inputHash[:])
	}

	// Hash outputs
	for _, output := range tx.Outputs {
		outputHash := output.hash()
		h.Write(outputHash[:])
	}

	return BytesToHash(h.Sum(nil))
}

// Assume locks: txPool
func (tx *Tx) getOutputs(gossiper *Gossiper, lookInPool bool) ([]*TxOutputLocation, bool) {
	var outputs []*TxOutputLocation
	anyMissing := false
	for _, input := range tx.Inputs {
		output, err := gossiper.getOutput(input)
		found := err == nil

		// Look in the pool if not found
		if lookInPool {
			if !found {
				output, err = gossiper.getOutputFromPool(input)
				if output != nil {
					found = true
				}
			}
		}

		if found {
			// If found, collect output, to check if spent later on (to go only once through the chain)
			location := &TxOutputLocation{
				Output:       output,
				OutputTxHash: input.OutputTxHash,
				OutputIdx:    input.OutputIdx,
			}
			outputs = append(outputs, location)
		} else {
			anyMissing = true
		}
	}

	return outputs, anyMissing
}

func (tx *Tx) equals(other *Tx) bool {
	if !tx.Sig.Equal(other.Sig) {
		return false
	}

	if !PublicKeyEqual(tx.PublicKey, other.PublicKey) {
		return false
	}

	for i, input := range tx.Inputs {
		if !input.equals(other.Inputs[i]) {
			return false
		}
	}

	for i, output := range tx.Outputs {
		if !output.equals(other.Outputs[i]) {
			return false
		}
	}

	return true
}

func (tx *Tx) size() int {
	size := 0

	// Inputs
	for _, input := range tx.Inputs {
		size += input.size()
	}

	// Outputs
	for _, output := range tx.Outputs {
		size += output.size()
	}

	// Suppose a big int sizes 8 bytes
	size += (8 * 4)

	return size
}

func (tx *Tx) toSerializable() (*SerializableTx, error) {

	R, err1 := tx.Sig.R.MarshalJSON()
	S, err2 := tx.Sig.S.MarshalJSON()
	X, err3 := tx.PublicKey.X.MarshalJSON()
	Y, err4 := tx.PublicKey.Y.MarshalJSON()
	if err1 != nil || err2 != nil || err3 != nil || err4 != nil {
		return nil, errors.New("Could not serialize R, S, X or Y")
	}

	serTx := &SerializableTx{
		Inputs:    tx.Inputs,
		Outputs:   tx.Outputs,
		Sig:       &SerializedSig{R: R, S: S},
		PublicKey: &SerializedPublicKey{X: X, Y: Y},
	}

	return serTx, nil
}

func (tx *SerializableTx) toNormal() (*Tx, error) {
	R, S, X, Y := &big.Int{}, &big.Int{}, &big.Int{}, &big.Int{}
	err1 := R.UnmarshalJSON(tx.Sig.R)
	err2 := S.UnmarshalJSON(tx.Sig.S)
	err3 := X.UnmarshalJSON(tx.PublicKey.X)
	err4 := Y.UnmarshalJSON(tx.PublicKey.Y)
	if err1 != nil || err2 != nil || err3 != nil || err4 != nil {
		return nil, errors.New("Could not deserialize R, S, X or Y")
	}

	newTx := &Tx{
		Inputs:    tx.Inputs,
		Outputs:   tx.Outputs,
		Sig:       &Sig{R: R, S: S},
		PublicKey: &PublicKey{X: X, Y: Y},
	}

	return newTx, nil
}

func (tx *Tx) String() string {
	res := fmt.Sprintf("\nTx generated by %s\n", PublicKeyToAddress(tx.PublicKey))

	// Inputs
	res += "- Inputs:\n"
	for _, input := range tx.Inputs {
		res += fmt.Sprintf("\t• Tx: %s, Idx: %d\n", hex.EncodeToString(input.OutputTxHash[:]), input.OutputIdx)
	}

	// Ouputs
	res += "- Outputs:\n"
	for _, output := range tx.Outputs {
		res += fmt.Sprintf("\t• %d tibcoins to %s\n", output.Value, output.To)
	}

	return res
}

// Tx inputs internals
func (in *TxInput) hash() [32]byte {
	h := sha256.New()
	h.Write(in.OutputTxHash[:])
	h.Write([]byte(strconv.Itoa(int(in.OutputIdx))))
	return BytesToHash(h.Sum(nil))
}

func (in *TxInput) equals(other *TxInput) bool {
	return bytes.Equal(in.OutputTxHash[:], other.OutputTxHash[:]) && in.OutputIdx == other.OutputIdx
}

func (in *TxInput) references(tx *Tx) bool {
	txHash := tx.hash()
	return bytes.Equal(txHash[:], in.OutputTxHash[:]) && int(in.OutputIdx) < len(tx.Outputs)
}

func (in *TxInput) sameOutput(other *TxInput) bool {
	return bytes.Equal(in.OutputTxHash[:], other.OutputTxHash[:]) && in.OutputIdx == other.OutputIdx
}

func (in *TxInput) sameOutputLocation(other *TxOutputLocation) bool {
	return bytes.Equal(in.OutputTxHash[:], other.OutputTxHash[:]) && in.OutputIdx == other.OutputIdx
}

// Asuume lock: txPool
func (gossiper *Gossiper) getOutputFromPool(in *TxInput) (*TxOutput, error) {
	for _, other := range gossiper.txPool {
		if in.references(other) {
			return other.Outputs[in.OutputIdx], nil
		}
	}

	return nil, fmt.Errorf("Output not found in tx pool for input %x", in.hash())
}

// We are looking only in the main branch for a correpsonding transaction
// Assume locks: topBlock, blocks
func (gossiper *Gossiper) getOutput(in *TxInput) (*TxOutput, error) {
	// Get top block hash
	topBlock := gossiper.topBlock

	// Get top block
	currentBlock, blockExists := gossiper.blocks[topBlock]

	if !blockExists {
		return nil, fmt.Errorf("Top block (hash = %x) not found in 'gossiper.blocks'", topBlock[:])
	}

	for blockExists {
		// Check if block contains transaction we are looking for
		for _, tx := range currentBlock.Txs {
			txHash := tx.hash()
			if bytes.Equal(txHash[:], in.OutputTxHash[:]) {
				if in.OutputIdx < len(tx.Outputs) {
					return tx.Outputs[in.OutputIdx], nil
				}
				return nil, fmt.Errorf("Tx found (hash = %x) but not enough output: expected at least %d, got %d", txHash[:], in.OutputIdx+1, len(tx.Outputs))
			}
		}

		// Get the previous block
		currentBlock, blockExists = gossiper.blocks[currentBlock.PrevHash]
	}

	return nil, fmt.Errorf("Tx not found in main branch (hash = %x)", in.OutputTxHash[:])
}

func (in *TxInput) size() int {
	// Hardcode input size
	return 4 + len(in.OutputTxHash)
}

func (out *TxOutput) legalMoneyRange() bool {
	return out.Value > 0 || out.Value < MaxCoins
}

func (out *TxOutput) hash() [32]byte {
	h := sha256.New()
	h.Write([]byte(out.To))
	h.Write([]byte(strconv.Itoa(int(out.Value))))
	return BytesToHash(h.Sum(nil))
}

func (out *TxOutput) equals(other *TxOutput) bool {
	return (out.To == other.To) && out.Value == other.Value
}

func (out *TxOutput) size() int {
	// Hardcode output size
	return 4 + len([]byte(out.To))
}
